'''
利用贝叶斯分类器对genderdata数据进行分类
'''

import pandas as pd
import math
import random
import numpy as np
# 取出数据
datasets = pd.read_excel('..\data\student2019.xlsx') # 默认跳过头了
datasets = (np.array(datasets)).tolist()
# print(type(datasets[1][0]),type(datasets[1][1]))
# print(type(datasets))
# print(datasets)

class Bayes(object):
  def __init__(self,train_data):
    self.data = train_data
    # 存放每个特征的方差
    self.model_para = {}

  def mean(self,data):
    if type(data[0]) == str:
      return
    return sum(data)/float(len(data))

  def std(self,data):
  # 计算方差,公式为 [((x1-x)^2 + (x2-x)^2 + (x3-x)^3 + ...)/n - 1]^0.5
    if type(data[0]) == str:
      return
    mean = self.mean(data)
    sum = 0
    for x in data:
      sum += pow(x - mean,2)
    n = len(data) - 1
    temp = sum/float(n)
    return math.sqrt(temp)

  # 对每一类样本的每个特征计算均值和方差，结果保存在列表中，依次为第一维特征、第二维特征等...的均值和方差
  def summarize(self, vectors):
    # zip利用 * 号操作符，可以将不同元组或者列表压缩为为列表集合。用来提取每类样本下的每一维的特征集合
    summaries = [(self.mean(attribute), self.std(attribute)) for attribute in zip(*vectors)]
    # 将代表类别的最后一个数据删掉，只保留均值和方差
    del summaries[-1]
    return summaries

  def cal_probability(self,x,mean,std):
  # 计算每一个特征的概率密度
    a = -(pow(x - mean,2))
    b = 2 * pow(std,2)
    exponent = math.exp(a/b)
    left = 1 / math.sqrt(b * math.pi)
    return left * exponent

  def cal_class_pro(self,input_data):
    # input_data 一个待分类数据
    probabilities = {}

    for class_value,class_sum in self.model_para.items():
      probabilities[class_value] = 1
      # len(class_sum) 特征个数
      for i in range(len(class_sum)):
        mean,std = class_sum[i]
        # 提取带分类数据的每一个特征值
        # 提取要测试的
        x = input_data[i]
        # 计算联合概率密度
        probabilities[class_value] *= self.cal_probability(x,mean,std)

    prediction = max(probabilities,key=probabilities.get)
    return prediction

  def train_bayes(self):
    # 把训练集按照男女分类
    seperated_class = {}
    for i in range(len(self.data)):
      student = self.data[i]
      # print(i,student)
      if student[-1] not in seperated_class:
        seperated_class[student[-1]] = []
      seperated_class[student[-1]].append(student)

    for class_value,student in seperated_class.items():
        # 将每一个类别的均值和方差保存在对应的键值对中
        # print(class_value,student)
        self.model_para[class_value] = self.summarize(student)
    return self.model_para


def load_dataset():
  return

def split_dataset():
  # 按照比例划分训练集和测试集
  # print(len(datasets))
  splitRatio = 0.90
  trainSize = int(len(datasets) * splitRatio)
  trainSet = []
  copy = list(datasets)
  while len(trainSet) < trainSize:
    index = random.randrange(len(copy))
    # 原始数据集剔除训练集之后剩下的就是测试集
    trainSet.append(copy.pop(index))
  return [trainSet, copy]


def cal_accurency(testData,bayes):
  # 计算准确率
  correct_nums = 0
  for i in range(len(testData)):
    # 逐次计算每一个数据的分类类别
    if testData[i][-1] == bayes.cal_class_pro(testData[i]):
      correct_nums += 1
  return correct_nums

if __name__ == '__main__':

  trainData, testData = split_dataset()
  bayes = Bayes(trainData)
  # model为训练之后的bayes分类器模型的概率参数
  model = bayes.train_bayes()
  print(model)
  correct_nums = cal_accurency(testData, bayes)
  print("分类准确率 %f%%" % (correct_nums / len(testData) * 100.0))

